// Type definitions matching the database schema

// Enum Types
export type AppSemester = 'First Semester' | 'Second Semester' | 'Summer Term';
export type AppStatus = 'pending' | 'submitted' | 'under_review' | 'approved' | 'rejected' | 'withdrawn';
export type UserRole = 'scholar' | 'reviewer' | 'finance' | 'super_admin';
export type DocumentType = 
  | 'registration_cert'
  | 'birth_cert'
  | 'barangay_id'
  | 'shs_diploma'
  | 'good_moral_cert'
  | 'grades_cert'
  | 'residency_cert'
  | 'voter_cert_scholar'
  | 'voter_cert_guardian'
  | 'valid_id';
export type EducationLevel = 'Junior High School' | 'Senior High School' | 'College';

/**
 * Base User Profile - matches the users table
 */
export interface UserBase {
  id: string;
  email: string;
  first_name: string;
  last_name: string;
  middle_name?: string;
  gender: string;
  birthdate: string; // ISO format: YYYY-MM-DD
  contact_number: string;
  
  // Address Information
  address_line1?: string;
  address_line2?: string;
  barangay?: string;
  city?: string;
  province?: string;
  zip_code?: string;
  region?: string;
  years_of_residency?: number;

  // Metadata
  last_login?: string;
  profile_update_history?: any[];
  created_at?: string;
  updated_at?: string;
}

/**
 * Application - matches the applications table
 */
export interface Application {
  id: string;
  user_id: string;
  academic_year: string;
  semester: AppSemester;
  status: AppStatus;
  created_at?: string;
  updated_at?: string;
}

/**
 * Application Details - matches the application_details table
 */
export interface ApplicationDetails {
  id: string;
  application_id: string;
  
  // Guardian Information
  mother_maiden_name: string;
  mother_occupation?: string;
  father_name: string;
  father_occupation?: string;

  // Current School Details
  college_name: string;
  college_address: string;
  course: string;
  year_level: string;
  gpa: number;

  created_at?: string;
  updated_at?: string;
}

/**
 * Educational History - matches the educational_history table
 */
export interface EducationalHistory {
  id: string;
  application_id: string;
  level: EducationLevel;
  school_name: string;
  school_address: string;
  year_started: number;
  year_graduated?: number;
  strand?: string;
  with_honors: boolean;
  expected_graduation?: number;
  created_at?: string;
  updated_at?: string;
}

/**
 * Document - matches the documents table
 */
export interface Document {
  id: string;
  application_id: string;
  document_type: DocumentType;
  file_name: string;
  file_path: string;
  file_size: number;
  status: string;
  uploaded_at: string;
  created_at?: string;
  updated_at?: string;
}

/**
 * Registration interface for new users
 */
export interface UserRegistration extends Omit<UserBase, 'id' | 'created_at' | 'updated_at' | 'last_login' | 'profile_update_history'> {
  password: string;
  confirmPassword?: string; // Only used in UI, not stored
}

/**
 * Validation utilities for user data
 */
export const userValidation = {
  /**
   * Validates email format
   */
  validateEmail: (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  },

  /**
   * Validates contact number format for Philippine numbers
   */
  validateContactNumber: (number: string): { isValid: boolean; value?: string; error?: string } => {
    if (!number || number.trim() === '') {
      return { isValid: false, error: 'Contact number is required' };
    }
    
    const cleaned = number.replace(/\D/g, '');
    
    // Handle different Philippine mobile number formats
    if (cleaned.length === 10 && cleaned.startsWith('9')) {
      // 10 digits: 9171234567 -> add leading 0
      return { isValid: true, value: '0' + cleaned };
    } else if (cleaned.length === 11 && cleaned.startsWith('09')) {
      // 11 digits: 09171234567 -> standard format
      return { isValid: true, value: cleaned };
    } else if (cleaned.length === 12 && cleaned.startsWith('639')) {
      // 12 digits with country code: 639171234567 -> convert to 09171234567
      return { isValid: true, value: '0' + cleaned.substring(2) };
    }
    
    return { isValid: false, error: 'Invalid contact number format' };
  },

  /**
   * Validates zip code format (4 digits)
   */
  validateZipCode: (zipCode: string): boolean => {
    return /^\d{4}$/.test(zipCode);
  },

  /**
   * Validates GPA format (between 1.00 and 4.00)
   */
  validateGPA: (gpa: number): boolean => {
    return gpa >= 1.00 && gpa <= 4.00;
  },

  /**
   * Validates year (between 2000 and 2030)
   */
  validateYear: (year: number): boolean => {
    return year >= 2000 && year <= 2030;
  },

  /**
   * Validates file size (max 10MB)
   */
  validateFileSize: (size: number): boolean => {
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB in bytes
    return size <= MAX_FILE_SIZE;
  }
}
      return { isValid: true, value: cleaned };
    }
    
    return { isValid: false, error: 'Please enter a valid mobile number (e.g., 09171234567)' };
  },

  /**
   * Validates required fields
   * @param fields Object with field names and values to validate
   * @returns Array of missing required fields
   */
  validateRequiredFields: (fields: Record<string, any>): string[] => {
    const requiredFields = ['firstName', 'lastName', 'email', 'gender', 'birthdate'];
    const missing: string[] = [];
    
    requiredFields.forEach(field => {
      if (!fields[field] || fields[field].toString().trim() === '') {
        missing.push(field);
      }
    });
    
    return missing;
  },
  
  /**
   * Validates ZIP code format
   * @param zipCode ZIP code to validate
   * @returns Whether the ZIP code is valid
   */
  validateZipCode: (zipCode: string): boolean => {
    return /^\d{4}$/.test(zipCode);
  },
  
  /**
   * Formats date from ISO to MM/DD/YYYY display format
   * @param isoDate Date in ISO format
   * @returns Date in MM/DD/YYYY format
   */
  formatDateForDisplay: (isoDate: string): string => {
    if (!isoDate) return '';
    const date = new Date(isoDate);
    if (isNaN(date.getTime())) return '';
    
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const year = date.getFullYear();
    
    return `${month}/${day}/${year}`;
  },
  
  /**
   * Parses display date (MM/DD/YYYY) back to ISO format
   * @param displayDate Date in MM/DD/YYYY format
   * @returns Date in ISO format
   */
  parseDisplayDate: (displayDate: string): string => {
    if (!displayDate) return '';
    
    // Handle different formats: MM/DD/YYYY or MM-DD-YYYY
    const parts = displayDate.split(/[/\-]/);
    if (parts.length !== 3) return '';
    
    const month = parts[0].padStart(2, '0');
    const day = parts[1].padStart(2, '0');
    const year = parts[2];
    
    return `${year}-${month}-${day}`;
  }
};